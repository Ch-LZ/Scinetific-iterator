# Scinetific-iterator
[![CI](https://github.com/Ch-LZ/Scinetific-iterator/actions/workflows/gradle.yml/badge.svg?branch=main)](https://github.com/Ch-LZ/Scinetific-iterator/actions/workflows/gradle.yml)
![Wait free impl badge](https://img.shields.io/badge/shapshot-wait--free-brightgreen)
[![](https://tokei.rs/b1/github/Ch-LZ/Scinetific-iterator?category=code)](https://github.com/Ch-LZ/Scinetific-iterator)
![GitHub repo size](https://img.shields.io/github/repo-size/Ch-LZ/Scinetific-iterator)


# Description
На других языках:
[English](README.md)
[Русский](README.ru.md) \
$\qquad$ Disclaimer: Реализация никак не связана с авторами статьи. Сделана в качестве личного учебного проекта. Надеюсь, эта реализация поможет другим лучше понять алгоритм.

$\qquad$ Wait-free итератор, основанный для снятии снапшота. Реализован для lock-free списка согласно статье. 
Многие комментарии в коде включают фрагменты статьи (а иногда и состоят из них).

$\qquad$ Из-за некоторых оптимизаций, описанных в статье, снятие снапшота в двух местах полагается на реализацию множества: в ScannerStorage.oneTryPutOrdered и в SnapshotManager. Их логику безусловно может отделить от реализации множества, но она оставлена как есть для простоты. В остальных ситуациях ссылка на Node используется в качестве уникального идентификатора.

## Основная идея алгоритма
$\qquad$ Основная идея снятия снапшота состоит в следующем. Когда некоторый поток начинает снимать снапшот, потоки,
изменяющие структуру данных должны предоставить отчеты об изменениях. Для поддержания порядка операций потоки-писатели должны отсылать отчёты и о "чужих уcпехах", в случаях если
1) либо требуется чтобы "чужие успехи" линеаризовались раньше соответствующих операций потоков-писателей,
2) или есть опасность, что итератор не отразит изменений других потоков. Это позволяет сделать снапшот согласованным.

$\qquad$ После однократного сканирования списка целиком, параллельно собранные отчеты используются для валидизирования снапшота.

$\qquad$ Главный объект во всём алгоритме снятия снапшота - SnapCollector.
Он отвечает за сбор отчетов потоками, одновременную линеаризацию отчетов от всех (через CAS).

## Краткий обзор реализации
$\qquad$ Ключевой объект в алгоритме снятия снапшота - SnapCollector. Он отвечает за точки линеаризации всего процесса снятия снапшота. Он также собирает отчеты об изменениях и увиденные узлы от одновременно итерирующихся потоков. \
$\qquad$ Хранение отчетов обеспечивают ReportStorage и ScannerStorage. Они имеют схожее внутреннее устройство, основанное на известной очереди Майкла-Скотта, реализованной в GenericStorage. Хранимые элементы - не значения, а ссылки на узлы. Это предоставляет уникальный идентификатор, необходимый в процессе валидации снапшота.

$\qquad$ SnapshotManager логически отделяет снятие снапшота от других операций множества. Кроме того он логически помечает операции отправки отчетов в реализации. Он отражает порядок действий алгоритма снятия снапшота.

# Понимание механизма отчетов
$\qquad$ Что заставляет такой подход работать? Как можно было придумать такой? Под этим заголовком попытка ответить на эти вопросы и обобщить идею.

## Наглядно и просто
Посмотрим на жизненный цикл узлов: \
![node fsm diagram](.github/images/node_fsm_diagram.png "Node fms diagram") \
Заглавными буквами подписаны типы отправляемых отчетов.
$\qquad$ Из диаграммы легко заметить, что отчеты отпраляются тогда, когда какой-то поток находит узел в конкретном состоянии или пытается его изменить. Это значит, что поток должен отправить отчет, когда результат его операции может зависит от состояния узла. 

$\qquad$ Когда собранные отчеты обрабатываются в процессе валидации снапшота, сначала INSERTED узлы добавляются ко всем увиденным в множестве, затем все DELETED узлы удаляются. В результате каждый узел появляется в своем последнем состоянии. Этот процесс легко представить на графе. Пусть удалось отсеять все отчеты для какого-то узла и затем переходы между состояниями, отраженные в этих отчетах были подсвечены на диаграмме состояний. Наиболее удалённая от начала подсвеченная стрелка будет указывать на искомое состояние.

В случае узла в lock-free связном списке, его состояние кодируется митовой меткой на AtomicMarkableReference.

## Есть ли что-то особенное в этой диаграмме?
Что в этом графе такого, что позволяет валидизировать состояние узла по отчетам? Может у него какая-то особенная структура?

1. Каждый отчет соответствует ровно одному изменения состояния (одной стрелке)
  - INSERTED - в множестве
  - DELETED - логически удален
2. Граф без циклов.
  - Рассмотрим граф который сам - цикл и пусть SnapCollector получил отчеты от каждого состояния цикла. Так как порядок полученных отчетов не определён, никто не сможет так просто вычислить какое состояние было последним.

Этих условий кажется хватает, чтобы коненое состояние можно было найти.

## Можно ли добавить циклы?
$\qquad$ Наиболее очевидное решение - поддерживать число переходов в узле. Добавление в отчет такого числа позволит находить не только самое позднее состояние, но и частично восстановить путь на графе состояний.

# Использованные источники

- lock-free set algorithm is implemented according to the book \
  Herlihy M., Shavit N. The Art of Multiprocessor Programming (220 - 226)
- iterator algorithm is implemented almost according to the article but with some restrictions. \
  Petrank E., Timnat S. Lock-free data-structure iterators //International Symposium on Distributed Computing. –
  Springer, Berlin, Heidelberg, 2013. – С. 224-238.
  https://link.springer.com/chapter/10.1007/978-3-642-41527-2_16
